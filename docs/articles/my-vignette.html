<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Convex Optimization by convexjlr • convexjlr</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.3.7/cerulean/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha256-U5ZEeKfGNOja007MMD3YBI0A3OSZOQbeG6z2f2Y0hu8=" crossorigin="anonymous"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" integrity="sha256-FiZwavyI2V6+EXO1U+xzLG3IKldpiTFf3153ea9zikQ=" crossorigin="anonymous"></script><!-- sticky kit --><script src="https://cdnjs.cloudflare.com/ajax/libs/sticky-kit/1.1.3/sticky-kit.min.js" integrity="sha256-c4Rlo1ZozqTPE2RLuvbusY3+SU1pQaJC0TjuhygMipw=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Convex Optimization by convexjlr">
<meta property="og:description" content="">
<meta name="twitter:card" content="summary">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">convexjlr</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">0.8.0.9000</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/my-vignette.html">Convex Optimization by convexjlr</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/Non-Contradiction/convexjlr">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1>Convex Optimization by convexjlr</h1>
                        <h4 class="author">Changcheng Li</h4>
            
            <h4 class="date">2018-12-15</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/Non-Contradiction/convexjlr/blob/master/vignettes/my-vignette.Rmd"><code>vignettes/my-vignette.Rmd</code></a></small>
      <div class="hidden name"><code>my-vignette.Rmd</code></div>

    </div>

    
    
<p>The aim of package <code>convexjlr</code> is to provide optimization results rapidly and reliably in <code>R</code> once you formulate your problem as a convex problem. Having this in mind, we write this vignette in a problem-oriented style. The vignette will walk you through several examples using package <code>convexjlr</code>:</p>
<ul>
<li>Lasso;</li>
<li>Logistic regression;</li>
<li>Support Vector Machine (SVM);</li>
<li>Smallest circle covering multiple points.</li>
</ul>
<p>Although these problems already have mature solutions, the purpose here is to show the wide application of convex optimization and how you can use <code>convexjlr</code> to deal with them easily and extendably.</p>
<p>Some of the examples here are of statistics nature (like Lasso and logistic regression), and some of the examples here are of machine-learning nature (like SVM), they may be appealing to readers with certain backgrounds. If you don’t know either of this, don’t be afraid, the smallest circle problem requires no certain background knowledge.</p>
<p>We hope you can get ideas for how to use <code>convexjlr</code> to solve your own problems by reading these examples. If you would like to share your experience on using <code>convexjlr</code>, don’t hesitate to contact me: <a href="mailto:cxl508@psu.edu">cxl508@psu.edu</a>.</p>
<p>Knowledge for convex optimization is not neccessary for using <code>convexjlr</code>, but it will help you a lot in formulating convex optimization problems and in using <code>convexjlr</code>.</p>
<ul>
<li>
<a href="https://en.wikipedia.org/wiki/Convex_optimization">Wikipedia page for convex optimization</a> is a good starting point.</li>
<li>
<a href="http://dcp.stanford.edu/">The page for Disciplined Convex Programming</a> can teach you more about DCP, which is the basis for <code>Convex.jl</code> and thus <code>convexjlr</code>.</li>
<li>
<a href="https://github.com/JuliaOpt/Convex.jl">Github page for <code>Convex.jl</code></a> can give you more imformation for <code>Convex.jl</code>, which <code>convexjlr</code> is built upon.</li>
</ul>
<p>To use package <code>convexjlr</code>, we first need to attach it and do some initial setup:</p>
<pre><code><a href="https://www.rdocumentation.org/packages/base/topics/Random">## sed seed for reproduciblity
set.seed(123)

library(convexjlr)

## 
## Attaching package: 'convexjlr'

## The following object is masked from 'package:base':
## 
##     norm

convex_setup(backend = "JuliaCall")

## Doing initialization. It may take some time. Please wait.

## Julia version 1.0.2 at location /Applications/Julia-1.0.app/Contents/Resources/julia/bin will be used.

## Loading setup script for JuliaCall...

## Finish loading setup script for JuliaCall.

## [1] TRUE</a></code></pre>
<div id="lasso" class="section level2">
<h2 class="hasAnchor">
<a href="#lasso" class="anchor"></a>Lasso</h2>
<p>Lasso is a variable selection and coefficient estimation method for linear regression. Interested reader can see <a href="http://statweb.stanford.edu/~tibs/lasso.html">the Lasso Page</a> and the Wikipedia page <a href="https://en.wikipedia.org/wiki/Lasso_(statistics)">Lasso (statistics)</a> for more information.</p>
<p>Let us first see the <code>lasso</code> function using <code>convexjlr</code>:</p>
<pre><code>lasso &lt;- function(x, y, lambda){
    p &lt;- ncol(x)
    ## n is a scalar, you don't have to use J(.) to send it to Julia.
    n &lt;- nrow(x) ## n &lt;- J(nrow(x))
    ## lambda is a scalar, you don't have to use J(.) to send it to Julia.
    ## lambda &lt;- J(lambda)
    ## x is a matrix and y is a vector, you have to use J(.) to send them to Julia.
    x &lt;- J(x)
    y &lt;- J(y)
    ## coefficient vector beta and intercept b.
    beta &lt;- Variable(p)
    b &lt;- Variable()
    ## MSE is mean square error.
    MSE &lt;- Expr(sumsquares(y - x %*% beta - b) / n)
    ## the L-1 penalty term of Lasso.
    penalty &lt;- Expr(lambda * sum(abs(beta)))
    ## In Lasso, we want to minimize the sum of MSE and penalty.
    p1 &lt;- minimize(MSE + penalty)
    cvx_optim(p1)
    list(coef = value(beta), intercept = value(b))
}</code></pre>
<p>In the function, <code>x</code> is the predictor matrix, <code>y</code> is the response we have, <code>lambda</code> is the positive tuning parameter which controls the sparsity of the estimation. And the <code>lasso</code> function will return the coefficient and intercept solved by <code>cvx_optim</code>.</p>
<p>Now we can see a little example using the <code>lasso</code> function we have just built.</p>
<pre><code>n &lt;- 1000
p &lt;- 100
## Sigma, the covariance matrix of x, is of AR-1 strcture.
Sigma &lt;- outer(1:p, 1:p, function(i, j) 0.5 ^ abs(i - j))
x &lt;- matrix(rnorm(n * p), n, p) %*% chol(Sigma)
## The real coefficient is all zero except the first, second and fourth elements.
beta0 &lt;- rep(0, p)
beta0[1:4] &lt;- c(5, 1, 0, 2)
y &lt;- x %*% beta0 + 0.2 * rnorm(n)

betahat &lt;- round(lasso(x, y, 0.5)$coef, 4)
betahat[1:4]

## [1] 4.8192 0.9062 0.0000 1.8094

## You can see that the rest elements of betahat are all zero.
all(betahat[5:p] == 0)

## [1] TRUE</code></pre>
</div>
<div id="logistic-regression" class="section level2">
<h2 class="hasAnchor">
<a href="#logistic-regression" class="anchor"></a>Logistic Regression</h2>
<p>Logistic regression is a widely used method in Generalized Linear Model (GLM) to deal with binary response. Interested reader can see the Wikipedia page <a href="https://en.wikipedia.org/wiki/Logistic_regression">Logistic regression</a> for more information.</p>
<p>Let us first see the <code>logistic_regression</code> function using <code>convexjlr</code>:</p>
<pre><code>logistic_regression &lt;- function(x, y){
    p &lt;- ncol(x)
    ## x is a matrix and y is a vector, you have to use J(.) to send them to Julia.
    x &lt;- J(x)
    y &lt;- J(y)
    ## beta is the coefficient.
    beta &lt;- Variable(p)
    ## sum(y * (x %*% beta)) - sum(logisticloss(x %*% beta))
    ## is the log-likelihood for logistic regressio,
    ## logisticloss(x) = log(1+exp(x)).
    p1 &lt;- maximize(sum(y * (x %*% beta)) - sum(logisticloss(x %*% beta)))
    cvx_optim(p1)
    value(beta)
}</code></pre>
<p>In the function, <code>x</code> is the predictor matrix, <code>y</code> is the binary response we have (we assume it to be 0-1 valued).</p>
<p>We first construct the log-likelihood of the logistic regression, and then we use <code>cvx_optim</code> to maximize it. Note that in formulating the log-likelihood, there is a little trick: we use <code><a href="../reference/logisticloss.html">logisticloss(x %*% beta)</a></code> instead of <code><a href="https://www.rdocumentation.org/packages/base/topics/Log">log(1+exp(x %*% beta))</a></code>, that is because <code><a href="../reference/logisticloss.html">logisticloss(.)</a></code> is a convex function but by rule of Disciplined Convex Programming (DCP), we are not sure whether <code><a href="https://www.rdocumentation.org/packages/base/topics/Log">log(1+exp(.))</a></code> is convex or not.</p>
<p>Interested readers can check <a href="http://dcp.stanford.edu/rules" class="uri">http://dcp.stanford.edu/rules</a> for more information about the rule of DCP, and use <code>?operations</code> or check <a href="http://convexjl.readthedocs.io/en/stable/operations.html" class="uri">http://convexjl.readthedocs.io/en/stable/operations.html</a> for a full list of supported operations.</p>
<p>Now we can see a little example using the <code>logistic_regression</code> function we have just built.</p>
<pre><code>n &lt;- 500
p &lt;- 2
## Sigma, the covariance matrix of x, is of AR-1 strcture.
Sigma &lt;- outer(1:p, 1:p, function(i, j) 0.5 ^ abs(i - j))
x &lt;- matrix(rnorm(n * p), n, p) %*% chol(Sigma)
## the real logistic regression coefficient.
beta0 &lt;- c(1, -1)
## the probability for y = 1.
p0 &lt;- 1 / (1 + exp(-x %*% beta0 + 0.2 * rnorm(n)))
y &lt;- runif(n) &lt; p0

logistic_regression(x, y)

##            [,1]
## [1,]  0.9723167
## [2,] -0.9953277</code></pre>
</div>
<div id="support-vector-machine" class="section level2">
<h2 class="hasAnchor">
<a href="#support-vector-machine" class="anchor"></a>Support Vector Machine</h2>
<p>Support vector machine (SVM) is a classificaiton tool. In this vignette, we just focus on the soft-margin linear SVM. Interested reader can read more about SVM in the Wikipedia page <a href="https://en.wikipedia.org/wiki/Support_vector_machine">Support vector machine</a>.</p>
<p>Let us first see the <code>svm</code> function using <code>convexjlr</code>:</p>
<pre><code>svm &lt;- function(x, y, lambda){
    p &lt;- ncol(x)
    ## n is a scalar, you don't have to use J(.) to send it to Julia.
    n &lt;- nrow(x) ## n &lt;- J(nrow(x))
    ## lambda is a scalar, you don't have to use J(.) to send it to Julia.
    ## lambda &lt;- J(lambda)
    ## x is a matrix and y is a vector, you have to use J(.) to send them to Julia.
    x &lt;- J(x)
    y &lt;- J(y)
    ## w and b define the classification hyperplane &lt;w.x&gt; = b.
    w &lt;- Variable(p)
    b &lt;- Variable()
    ## hinge_loss, note that pos(.) is the positive part function. 
    hinge_loss &lt;- Expr(sum(pos(1 - y * (x %*% w - b))) / n)
    p1 &lt;- minimize(hinge_loss + lambda * sumsquares(w))
    cvx_optim(p1)
    list(w = value(w), b = value(b))
}</code></pre>
<p>In the function, <code>x</code> is the predictor matrix, <code>y</code> is the binary response we have (we assume it to be of negative one or one in this section). <code>lambda</code> is the positive tuning parameter which determines the tradeoff between the margin-size and classification error rate. As <code>lambda</code> becomes smaller, the classification error rate is more important. And the <code>svm</code> function will return the <code>w</code> and <code>b</code> which define the classification hyperplance as <code>&lt;w, x&gt; = b</code>.</p>
<p>Now we can see a little example using the <code>svm</code> function we have just built.</p>
<pre><code>n &lt;- 100
p &lt;- 2
## Sigma, the covariance matrix of x, is of AR-1 strcture.
Sigma &lt;- outer(1:p, 1:p, function(i, j) 0.5 ^ abs(i - j))
## We generate two groups of points with same covariance and different mean.
x1 &lt;- 0.2 * matrix(rnorm(n / 2 * p), n / 2, p) %*% chol(Sigma) + outer(rep(1, n / 2), rep(0, p))
x2 &lt;- 0.2 * matrix(rnorm(n / 2 * p), n / 2, p) %*% chol(Sigma) + outer(rep(1, n / 2), rep(1, p))
x &lt;- rbind(x1, x2)
## the label for the points.
y &lt;- c(rep(1, n / 2), rep(-1, n / 2))

r &lt;- svm(x, y, 0.5)
r

## $w
##            [,1]
## [1,] -0.4798997
## [2,] -0.4827123
## 
## $b
## [1] -0.4261342

## We can scatter-plot the points and 
## draw the classification hyperplane returned by the function svm.
plot(x, col = c(rep("red", n / 2), rep("blue", n / 2)))
abline(r$b / r$w[2], -r$w[1] / r$w[2])</code></pre>
<p><img src="original-vignette_files/figure-markdown_strict/unnamed-chunk-7-1.png"></p>
</div>
<div id="smallest-circle" class="section level2">
<h2 class="hasAnchor">
<a href="#smallest-circle" class="anchor"></a>Smallest Circle</h2>
<p>In the last section of the vignette, let us see an example without any background knowledge requirement.</p>
<p>Suppose we have a set of points on the plane, how can we find the smallest circle that covers all of them? By using <code>convexjlr</code>, the solution is quite straight-forward.</p>
<pre><code>if (!requireNamespace("plotrix", quietly = TRUE)) {
    stop("Package plotrix needed for this section of vignette to build. Please install it.")
}

center &lt;- function(x, y){
    ## x and y are vectors of coordinates of the points,
    ## since they are vectors, we need to use J(.) to send them to Julia.
    x &lt;- J(x)
    y &lt;- J(y)
    ## Suppose the center of the smallest circle is p: (p[1], p[2]).
    p &lt;- Variable(2)
    ## The square of radius of the circle that covers all the points
    ## is maximum((x - p[1]) ^ 2 + (y - p[2]) ^ 2).
    r2 &lt;- Expr(maximum(square(x - p[1]) + square(y - p[2])))
    ## We want to minimize r2.
    p1 &lt;- minimize(r2)
    cvx_optim(p1)
    value(p)
}</code></pre>
<p>In the function, <code>x</code> and <code>y</code> are vectors of coordinates of the points. And the <code>center</code> function will return the coordinates of the center of the smallest circle that covers all the points.</p>
<p>Now we can see a little example using the <code>center</code> function we have just built.</p>
<pre><code>n &lt;- 20
## Generate some random points.
x &lt;- rnorm(n)
y &lt;- rnorm(n)

p &lt;- center(x, y)
p

##            [,1]
## [1,] -0.4686643
## [2,]  0.2271158

## Draw the points and the smallest circle that covers all of them.
plot(x, y, asp = 1)
plotrix::draw.circle(p[1], p[2], radius = sqrt(max((x - p[1]) ^ 2 + (y - p[2]) ^ 2)))</code></pre>
<p><img src="original-vignette_files/figure-markdown_strict/unnamed-chunk-9-1.png"></p>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#lasso">Lasso</a></li>
      <li><a href="#logistic-regression">Logistic Regression</a></li>
      <li><a href="#support-vector-machine">Support Vector Machine</a></li>
      <li><a href="#smallest-circle">Smallest Circle</a></li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by Changcheng Li.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.3.0.</p>
</div>
      </footer>
</div>

  

  </body>
</html>
